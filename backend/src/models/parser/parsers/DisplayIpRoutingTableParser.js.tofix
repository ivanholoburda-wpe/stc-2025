const BaseParser = require('../core/BaseParser');

class DisplayIpRoutingTableParser extends BaseParser {
  constructor() {
    super();
    this.name = 'display_ip_routing_table_block';
    
    this.currentRoutingTable = null;

    this.rules = [
      {
        name: 'routing_table_header',
        regex: /^Routing Table\s*:\s*(?<name>\S+)/,
        handler: (match) => {
          const newTable = { name: match.groups.name, summary: {}, routes: [] };
          this.data.tables.push(newTable);
          this.currentRoutingTable = newTable;
        }
      },
      {
        name: 'summary_info',
        regex: /Destinations\s*:\s*(?<dest_count>\d+)\s+Routes\s*:\s*(?<route_count>\d+)/,
        handler: (match) => {
          if (this.currentRoutingTable) {
            this.currentRoutingTable.summary = {
              destinations: parseInt(match.groups.dest_count, 10),
              routes: parseInt(match.groups.route_count, 10),
            };
          }
        }
      },
      {
        name: 'route_entry',
        regex: /^\s*(?<Destination_Mask>\S+)\s+(?<Proto>\S+)\s+(?<Pre>\d+)\s+(?<Cost>\d+)\s+(?<TheRest>.*)$/,
        handler: (match) => {
          if (!this.currentRoutingTable) return;

          const rest = match.groups.TheRest.trim().split(/\s+/);
          const interfaceName = rest.pop();
          const next_hop = rest.pop();
          const flags = rest.join(' ') || null;

          this.currentRoutingTable.routes.push({
            destination_mask: match.groups.Destination_Mask,
            protocol: match.groups.Proto,
            preference: parseInt(match.groups.Pre, 10),
            cost: parseInt(match.groups.Cost, 10),
            flags: flags,
            next_hop: next_hop,
            interface: interfaceName,
          });
        }
      },
      {
        // üî• –ò–ó–ú–ï–ù–ï–ù–ò–ï –ó–î–ï–°–¨: –î–æ–±–∞–≤–ª—è–µ–º —Å–∞–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ —Ç–∞–±–ª–∏—Ü—ã –≤ —Å–ø–∏—Å–æ–∫ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º—ã—Ö —Å—Ç—Ä–æ–∫
        name: 'ignore_lines',
        regex: /^(?:Proto:|Route Flags:|---|Destination\/Mask)/,
        handler: () => { /* –ù–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º */ }
      }
    ];
  }

  /**
   * üî• –ò–ó–ú–ï–ù–ï–ù–ò–ï –ó–î–ï–°–¨: –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ —Ç–µ–ø–µ—Ä—å ‚Äî —ç—Ç–æ –ø—Ä–æ—Å—Ç–∞—è –∏ –Ω–∞–¥–µ–∂–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤.
   */
  isEntryPoint(line) {
    // –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –Ω–∞–π–¥–µ—Ç –∑–∞–≥–æ–ª–æ–≤–æ–∫.
    return line.includes('Destination/Mask') && line.includes('Proto') && line.includes('Pre');
  }

  startBlock(line, match) {
    super.startBlock(line, match);
    this.data = {
      type: this.name,
      tables: [],
    };
    this.currentRoutingTable = null;
  }
}

module.exports = DisplayIpRoutingTableParser;