const BaseParser = require('../core/BaseParser');

class DisplayIpRoutingTableParser extends BaseParser {
  constructor() {
    super();
    this.name = 'display_ip_routing_table_block';
    
    this.currentRoutingTable = null;

    this.rules = [
      {
        name: 'routing_table_header',
        regex: /^Routing Table\s*:\s*(?<name>\S+)/,
        handler: (match) => {
          const newTable = { name: match.groups.name, summary: {}, routes: [] };
          this.data.tables.push(newTable);
          this.currentRoutingTable = newTable;
        }
      },
      {
        name: 'summary_info',
        regex: /Destinations\s*:\s*(?<dest_count>\d+)\s+Routes\s*:\s*(?<route_count>\d+)/,
        handler: (match) => {
          if (this.currentRoutingTable) {
            this.currentRoutingTable.summary = {
              destinations: parseInt(match.groups.dest_count, 10),
              routes: parseInt(match.groups.route_count, 10),
            };
          }
        }
      },
      {
        name: 'route_entry',
        regex: /^\s*(?<Destination_Mask>\S+)\s+(?<Proto>\S+)\s+(?<Pre>\d+)\s+(?<Cost>\d+)\s+(?<TheRest>.*)$/,
        handler: (match) => {
          if (!this.currentRoutingTable) return;

          const rest = match.groups.TheRest.trim().split(/\s+/);
          const interfaceName = rest.pop();
          const next_hop = rest.pop();
          const flags = rest.join(' ') || null;

          this.currentRoutingTable.routes.push({
            destination_mask: match.groups.Destination_Mask,
            protocol: match.groups.Proto,
            preference: parseInt(match.groups.Pre, 10),
            cost: parseInt(match.groups.Cost, 10),
            flags: flags,
            next_hop: next_hop,
            interface: interfaceName,
          });
        }
      },
      {
        name: 'ignore_lines',
        regex: /^(?:Proto:|Route Flags:|---|Destination\/Mask)/,
        handler: () => { /* Ничего не делаем */ }
      }
    ];
  }

  isEntryPoint(line) {
    return line.includes('Destination/Mask') && line.includes('Proto') && line.includes('Pre');
  }

  startBlock(line, match) {
    super.startBlock(line, match);
    this.data = {
      type: this.name,
      tables: [],
    };
    this.currentRoutingTable = null;
  }
}

module.exports = DisplayIpRoutingTableParser;