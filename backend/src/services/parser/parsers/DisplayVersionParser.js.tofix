const BaseParser = require('../core/BaseParser');

/**
 * Парсер для вывода команды 'display version'.
 * Извлекает основную информацию об устройстве: модель, версию ПО, аптайм и данные о процессорной плате (IPU).
 */
class DisplayVersionParser extends BaseParser {
  constructor() {
    super();
    this.name = 'display_version_block';
    this.priority = 20; // Приоритет для определения парсера

    // Набор правил для извлечения данных из строк лога
    this.rules = [
        // ПРАВИЛА ДЛЯ ИГНОРИРОВАНИЯ (НОВЫЕ)
        {
          name: 'boilerplate_header_vrp',
          regex: /^Huawei Versatile Routing Platform Software/,
          handler: () => { /* Это ожидаемая строка, игнорируем ее */ }
        },
        {
          name: 'boilerplate_copyright',
          regex: /^Copyright \(C\)/,
          handler: () => { /* Это ожидаемая строка, игнорируем ее */ }
        },
        
        // ВАШИ СТАРЫЕ ПРАВИЛА ДЛЯ ИЗВЛЕЧЕНИЯ ДАННЫХ
        {
          name: 'software_version',
          regex: /^VRP \(R\) software, Version (?<version>.+)/,
          handler: (match) => { this.data.software_version = match.groups.version.trim(); }
        },
        {
          name: 'model_and_uptime',
          regex: /^HUAWEI (?<model>.+?) uptime is (?<uptime>.+)/,
          handler: (match) => {
            this.data.model = match.groups.model.trim();
            this.data.uptime = match.groups.uptime.trim();
          }
        },
        {
          name: 'ipu_uptime',
          regex: /^IPU .* uptime is (?<uptime>.+)/,
          handler: (match) => { this.data.ipu.uptime = match.groups.uptime.trim(); }
        },
        {
          name: 'memory_sizes',
          regex: /^(?<mem_type>SDRAM|FLASH|CFCARD) Memory Size\s+:\s+(?<size>\d+)\s+M bytes/,
          handler: (match) => {
            const type = match.groups.mem_type.toLowerCase();
            const size = parseInt(match.groups.size, 10);
            
            if (type === 'cfcard') {
              this.data.ipu.cfcard_mb = size;
            } else {
              this.data.ipu[`${type}_mb`] = size;
            }
          }
        }
      ];

    // Правила валидации для проверки полноты и корректности спарсенных данных
    this.addValidationRule({
      name: 'model_required',
      validate: (data) => data.model && data.model.length > 0,
      message: 'Device model is required but was not found'
    });

    this.addValidationRule({
      name: 'version_required',
      validate: (data) => data.software_version && data.software_version.length > 0,
      message: 'Software version is required but was not found'
    });
  }

  /**
   * Определяет, является ли строка точкой входа для этого парсера.
   * @param {string} line - Строка из лога.
   * @returns {object|null} - Результат совпадения (match) или null.
   */
  isEntryPoint(line) {
    // Блок начинается с команды 'display version'
    const regex = /^display version$/;
    return line.trim().match(regex);
  }

  /**
   * Инициализирует структуру данных при нахождении точки входа.
   * @param {string} line - Строка, на которой сработала точка входа.
   * @param {object} match - Результат совпадения из isEntryPoint.
   */
  startBlock(line, match) {
    super.startBlock(line, match);
    
    // Создаем чистую структуру для хранения результатов
    this.data = {
      ...this.data,
      software_version: null,
      model: null,
      uptime: null,
      ipu: {
        uptime: null,
        sdram_mb: null,
        flash_mb: null,
        cfcard_mb: null,
      }
    };
  }

  /**
   * Определяет, завершился ли блок данных для этого парсера.
   * @param {string} line - Текущая строка из лога.
   * @returns {boolean} - true, если блок завершен.
   */
  isBlockComplete(line) {
    const trimmedLine = line.trim();
    
    // Блок завершается, когда мы встречаем промпт устройства (например, <ta1-kie002>)
    if (/^<.+?>$/.test(trimmedLine)) {
      return true;
    }
    
    // Или когда встречаем разделитель между блоками
    if (trimmedLine.startsWith('=========######')) {
        return true;
    }
    
    return super.isBlockComplete(line);
  }
}

module.exports = DisplayVersionParser;
